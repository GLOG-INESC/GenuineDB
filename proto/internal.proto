syntax = "proto3";

import "proto/transaction.proto";
import "proto/api.proto";

package slog.internal;

message LocalBatchOrder {
    // generator is the machine that the 
    // batch is generated from
    uint32 generator = 1;
    uint32 slot = 2;
    uint32 leader = 3;
}

message RemoteBatchOrder {
    uint64 batch_id = 1;
    uint32 slot = 2;
    uint32 home = 3;
    bool need_ack = 4;
}

message Envelope {
    oneof type {
        Request request = 1;
        Response response = 2;
        bytes raw = 3;
    }
    uint32 from = 4;
}

/***********************************************
                    REQUESTS
***********************************************/
/**
 * The first message of a communication between two entities is
 * always a Request. Some types of Request needs a Response
 * (e.g. LookUpMasterRequest); names of these requests end with "Request".
 * Some others are one-way requests (e.g. PaxosPropose) and do not 
 * end with "Request".
 */
message Request {
    oneof type {
        Ping ping = 1;
        Signal signal = 2;
        BrokerRedirect broker_redirect = 3;
        ForwardTransaction forward_txn = 4;
        LookupMasterRequest lookup_master = 5;
        ForwardBatchData forward_batch_data = 6;
        ForwardBatchOrder forward_batch_order = 7;
        BatchReplicationAck batch_replication_ack = 8;
        PaxosPropose paxos_propose = 9;
        PaxosAcceptRequest paxos_accept = 10;
        PaxosCommitRequest paxos_commit = 11;
        RemoteReadResult remote_read_result = 12;
        FinishedSubtransaction finished_subtxn = 13;
        StatsRequest stats = 14;
        GraphLog graph_log = 15;
        /* Janus */
        JanusPreAcceptRequest janus_pre_accept = 16;
        JanusAcceptRequest janus_accept = 17;
        JanusCommit janus_commit = 18;
        JanusInquireRequest janus_inquire = 19;
        /* Ziplog */
        ZiplogNextEpochRequest order_epoch = 20;
        ZiplogApiRequest zip_request = 21;
        ZiplogBatchRequest zip_batch = 22;
        ForwardZiplogBatch zip_forward_batch = 23;
        ZiplogFinishClient zip_finish_client = 24;
        GlogBatchRequest glog_batch = 25;
        ForwardGlogTransaction glog_forward_txn = 26;
        AddClientRequest add_client = 27;
        UpdateRateRequest update_rate = 28;
        RemoveClientRequest remove_client = 29;
        /* SLOG */
        SlogBatchRequest slog_batch_forward = 30;
        /* TIGA */
        TigaPreAcceptRequest tiga_pre_accept = 31;
        TigaTimestampAgreementRequest timestamp_agreement = 32;
        TigaSpeculativeExecutionRequest spec_execution = 33;
        TigaSpeculationConfirmation spec_confirmation = 34;
        TigaFinishedSubtransaction tiga_finished_subtxn = 35;
    }
}

message Ping {
    int64 src_time = 1;
    uint32 dst = 2;
}

/**
 * Generic signal message
 */
message Signal {
}

message BrokerRedirect {
    uint64 tag = 1;
    uint32 channel = 2;
    bool stop = 3;
}

message ForwardTransaction {
    Transaction txn = 1;
    uint64 slot = 2;
}

message LookupMasterRequest {
    repeated uint64 txn_ids = 1;
    repeated bytes keys = 2;
}

message ForwardBatchData {
    repeated Batch batch_data = 1;
    // Machine that generated the batch
    uint32 generator = 2;
    // Batches generated by the same machine need to follow the
    // order of creation. This field is used to number the batches
    // following that order. It always start from 0 and increment by 1
    uint32 generator_position = 3;
    // Time of sending request to ordering layer
    uint64 ordering_sent = 4;
}

message ForwardBatchOrder {
    oneof locality {
        LocalBatchOrder local_batch_order = 1;
        RemoteBatchOrder remote_batch_order = 2;
    }
    uint64 ordering_received = 3;
}

message BatchReplicationAck {
    uint64 batch_id = 1;
}

message PaxosPropose {
    uint64 value = 1;
}

message PaxosAcceptRequest {
    uint32 ballot = 1;
    uint32 slot = 2;
    uint64 value = 3;
}

message PaxosCommitRequest {
    uint32 slot = 1;
    uint64 value = 2;
    uint32 leader = 3;
}

message RemoteReadResult {
    uint64 txn_id = 1;
    bool deadlocked = 2;
    uint32 partition = 3;
    repeated KeyValueEntry reads = 4;
    bool will_abort = 5;
    string abort_reason = 6;
    AbortCode abort_code = 7;
    // Used to calculate time it took for read to arrive
    uint64 issuing_time = 8;
}

message FinishedSubtransaction {
    Transaction txn = 1;
    uint32 partition = 2;
    uint32 region = 3;
    uint32 replica = 4;
}

message StatsRequest {
    uint64 id = 1;
    uint64 level = 2;
}

message GraphLogEntry {
    uint64 txn_id = 1;
    int32 num_partitions = 2;
    bool is_complete = 3;
    repeated uint64 incoming_edges = 4;
}

message GraphLog {
    repeated GraphLogEntry entries = 1;
}

message JanusDependency {
    uint64 txn_id = 1;
    uint32 target_partition = 2;
    uint64 participants_bitmap = 3;
}

message JanusPreAcceptRequest {
    Transaction txn = 1;
    int32 ballot = 2;
}

message JanusAcceptRequest {
    uint64 txn_id = 1;
    repeated JanusDependency deps = 2;
    int32 ballot = 3;
}

message JanusCommit {
    uint64 txn_id = 1;
    repeated JanusDependency deps = 2;
    Transaction txn = 3;
}

message JanusInquireRequest {
    repeated uint64 txn_id = 1;
}

message ZiplogClientSlot {
    uint64 client_id = 1;
    uint64 num_slots = 2;
    uint32 client_region = 3;
    TransactionType client_type = 4;
}
message ZiplogRegionSlots {
    repeated ZiplogClientSlot slots = 1;
    uint64 num_clients = 2;
    // Base sequence number this new epoch will start from
    uint64 gsn_base = 3;

    uint32 region = 4;
}

message ZiplogNextEpochRequest {
    repeated ZiplogRegionSlots regions = 1;
    uint64 epoch_start = 2;
}



message ZiplogApiRequest {
    slog.api.Request request = 1;
}

message ZiplogBatchRequest {
    Batch txns = 1;
    uint64 slots = 2;
    uint64 client_id = 3;
    uint32 sent_batches = 4;
    TransactionType client_type = 5;
}

message ForwardZiplogBatch {
    repeated Batch batch_data = 1;
    // Ziplog client stub that generated the batch
    uint64 generator = 2;
    // Batches generated by the same machine need to follow the
    // order of creation. This field is used to number the batches
    // following that order. It always start from 0 and increment by 1
    uint32 generator_position = 3;
    // Time of sending request to ordering layer
    uint64 ordering_sent = 4;
    // Number of slots to advance from the generator
    uint64 slots = 5;
    // Region of the transaction
    uint64 home = 6;
    // Bollean signaling a noop batch
    bool noop = 7;
}

// Empty message to signal client shutting down
message ZiplogFinishClient {
    uint64 client_id = 1;
}

message SlogBatchRequest {
    repeated Batch batches = 1;
}

message GlogBatch {
    Batch txns = 1;
        // Total order slot to identify batch
        uint64 slot = 2;
}
message GlogBatchRequest {
    repeated GlogBatch batches = 1;
}

message ForwardGlogTransaction {
    ForwardTransaction forward_request = 1;
    repeated uint64 network_latencies = 2;
}

message AddClientRequest {
    uint64 client_id = 1;
    uint32 region = 2;
    uint32 machine_id = 3;
    uint64 num_slots = 4;
    bool   single_home_stub = 5;
}

message UpdateRateRequest {
    uint64 client_id = 1;
    uint64 num_slots = 2;
}

message RemoveClientRequest {
    uint64 client_id = 1;
}

message RemoveClientConfirmation {
    uint64 client_id = 1;
}

message TigaPreAcceptRequest {
    Transaction txn = 1;
    uint64 proposed_timestamp = 2;
}

message TigaTimestampAgreementRequest {
    uint64 txn_id = 1;
    uint64 proposed_ts = 2;
}

message TigaSpeculativeExecutionRequest {
    Transaction txn = 1;
    uint64 timestamp = 2;
    bool speculative = 3;
    /* Used when reissuing for exeuction */
    uint64 txn_id = 4;
}

message TigaSpeculationConfirmation {
    uint64 txn_id = 1;
    bool spec_confirmation = 2;
}

message TigaFinishedSubtransaction {
    FinishedSubtransaction finished_subtxn = 1;
    uint64 timestamp = 2;
}
/***********************************************
                    RESPONSES
***********************************************/
/**
 * A response is always preceeded by a Request
 */
message Response {
    oneof type {
        Pong pong = 1;
        LookupMasterResponse lookup_master = 2;
        PaxosAcceptResponse paxos_accept = 3;
        PaxosCommitResponse paxos_commit = 4;
        StatsResponse stats = 6;
        /* Janus */
        JanusPreAcceptResponse janus_pre_accept = 7;
        JanusAcceptResponse janus_accept = 8;
        JanusInquireResponse janus_inquire = 9;

       /* Ziplog */
        ZiplogApiResponse zip_response = 10;
        ZiplogFinishClientResponse client_finish_response = 11;

        ZiplogClientNextEpochRequest client_epoch = 12;
        RemoveClientConfirmation remove_client_confirmation = 13;
    }
}

/**
 * For debugging and testing purposes
 */
message Pong {
    int64 src_time = 1;
    int64 dst_time = 2;
    uint32 dst = 3;
}

message KeyMasterMetadata {
    bytes key = 1;
    MasterMetadata metadata = 2;
}

message LookupMasterResponse {
    repeated uint64 txn_ids = 1;
    repeated KeyMasterMetadata lookup_results = 2;
}

message PaxosAcceptResponse {
    uint32 ballot = 1;
    uint32 slot = 2;
}

message PaxosCommitResponse {
    uint32 slot = 1;
}

message StatsResponse {
    uint64 id = 1;
    bytes stats_json = 2;
}

message JanusPreAcceptResponse {
    uint64 txn_id = 1;
    bool ok = 2;
    repeated JanusDependency deps = 3;
}

message JanusAcceptResponse {
    uint64 txn_id = 1;
    bool ok = 2;
}

message JanusInquiryResult {
    uint64 txn_id = 1;
    bool executed = 2;
    repeated JanusDependency deps = 3;
}

message JanusInquireResponse {
    repeated JanusInquiryResult results = 1;
}

message ZiplogApiResponse {
    slog.api.Response response = 1;
}

message ZiplogFinishClientResponse {
    bool success = 1;
}

message ZiplogClientNextEpochRequest {
    uint64 num_slots = 1;
    // Start time of next epoch
    uint64 begin = 2;
}